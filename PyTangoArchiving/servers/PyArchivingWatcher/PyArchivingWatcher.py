#    "$Name:  $";
#    "$Header:  $";
#=============================================================================
#
# file :        PyArchivingWatcher.py
#
# description : Python source for the PyArchivingWatcher and its commands. 
#                The class is derived from Device. It represents the
#                CORBA servant object which will be accessed from the
#                network. All commands which can be executed on the
#                PyArchivingWatcher are implemented in this file.
#
# project :     TANGO Device Server
#
# $Author:  $
#
# $Revision:  $
#
# $Log:  $
#
# copyleft :    European Synchrotron Radiation Facility
#               BP 220, Grenoble 38043
#               FRANCE
#
#=============================================================================
#          This file is generated by POGO
#    (Program Obviously used to Generate tango Object)
#
#         (c) - Software Engineering Group - ESRF
#=============================================================================
#


import PyTango
import sys,multiprocessing,time,traceback,re,pickle
import fandango,PyTangoArchiving

import fandango.functional as fun
import fandango.web as web
from collections import defaultdict
import PyTangoArchiving.utils as utils
import PyTangoArchiving.files as files


class PyArchivingWatcher(PyTango.Device_4Impl):

#--------- Add you global variables here --------------------------

    def summarize(self,seq,seq2=[],NMAX=5):
        #Max number of attrs to display in a single line
        #seq = [seq for seq in seq if seq]
        #return str(seq) if len(seq)<NMAX else '[%d]'%len(seq)
        if not fun.isSequence(seq): 
            if type(seq) is float:
                if seq>1e-2 or not seq: 
                    if 0<=seq<=.9:
                        return color(web.bold('%1.2f'%seq),'red')
                    else:
                        return '%1.2f'%seq
                else: 
                    return '%1.2e'%seq
            else: return seq
        res = fandango.device.reduce_distinct(seq,seq2) if seq2 else (seq,1.0)
        if seq and len(res[0])<NMAX and res[1]>.5:
            return '%d, like:<br>%s' % (len(seq),'<br>'.join(res[0]))
        else:
            return '%d'%len(seq)

#------------------------------------------------------------------
#    Device constructor
#------------------------------------------------------------------
    def __init__(self,cl, name):
        PyTango.Device_4Impl.__init__(self,cl,name)
        PyArchivingWatcher.init_device(self)

#------------------------------------------------------------------
#    Device destructor
#------------------------------------------------------------------
    def delete_device(self):
        print "[Device delete_device method] for device",self.get_name()


#------------------------------------------------------------------
#    Device initialization
#------------------------------------------------------------------
    def init_device(self):
        print "In ", self.get_name(), "::init_device()"
        self.set_state(PyTango.DevState.ON)
        self.get_device_properties(self.get_device_class())
        
        self.domreg,self.argfilters,self.argexclude = '',{},{}
        if self.Filters:
            for f in filters:
                if f.startswith('domains:'):
                    self.domreg = fun.toRegexp(f.replace('domains:',''))
                elif f.startswith('exclude:'):
                    f = f.replace('exclude:','')
                    if ':' not in f:
                        self.argexclude = {'name':f}
                    else:
                        self.argexclude = dict((s.split(':') for s in f.split(',') if ':' in s))
                    if 'type' in self.argexclude: 
                        self.argexclude['type'] = '(stop|%s)'%self.argexclude['type']
                    else: 
                        self.argexclude['type'] = 'stop'

                else:
                    f = f.replace('filters:','')
                    if ':' not in f:
                        self.argfilters = {'name':f}
                    else:
                        self.argfilters = dict((s.split(':') for s in f.split(',') if ':' in s))
                        
        self.results = {}
        self.summary = {}
        self.failed = {}
        self.polizons = {}
        
        #Overridable by fandango.web?
        self.camel = lambda s: ''.join(r[0].upper()+(r[1:] or '').lower() for r in s.split())
        self.color = lambda s,color: '<font color="%s">%s</font>'%(camel(color),s)
        
        # Getting the CSV input files
        self.configs = []
        if self.domreg:
            self.configs = []
        elif self.InputFiles:
            for f in self.InputFiles:
                if '/' in f: 
                    self.configs.extend(sorted(files.GetConfigFiles(*f.rsplit('/',1))))
                else:
                    self.configs.extend(sorted(files.GetConfigFiles(mask=f)))
        else:
            self.configs = sorted(files.GetConfigFiles())
        
        print '#'*80
        print '%s, In archiving_report.py: reading %s, generating %s' % (time.ctime(),self.configs or self.domreg,self.HtmlFile)
        self.cron = fandango.threads.CronTab(self.CronTab,task=self.CheckAll,start=True,process=True,keep=10,trace=True)
                        

#------------------------------------------------------------------
#    Always excuted hook method
#------------------------------------------------------------------
    def always_executed_hook(self):
        print "In ", self.get_name(), "::always_excuted_hook()"
        
        try:
            while True:
                #It should return a list/dict of (schema,configuration,dictionary) tuples ; generated by a previous CheckAll()
                #the value when configuration == "summary" will be used to generate device status
                result = self.cron.get()
                try:
                    self.results[result[0]] = result[1]
                except:
                    print 'Exception in always_executed_hook(): queue.get(): \n%s'%traceback.format_exc()
        except: pass
            

#==================================================================
#
#    PyArchivingWatcher read/write attribute methods
#
#==================================================================
#------------------------------------------------------------------
#    Read Attribute Hardware
#------------------------------------------------------------------
    def read_attr_hardware(self,data):
        print "In ", self.get_name(), "::read_attr_hardware()"




#==================================================================
#
#    PyArchivingWatcher command methods
#
#==================================================================

#------------------------------------------------------------------
#    CheckFile command:
#
#    Description: 
#    argin:  DevString    
#    argout: DevString    
#------------------------------------------------------------------
    def CheckFile(self, argin):
        print "In ", self.get_name(), "::CheckFile()"
        #    Add your own code here
        
        return argout
    
#------------------------------------------------------------------
#    CheckAll command:
#
#    Description: 
#    argin:  DevVoid    
#    argout: DevString    
#------------------------------------------------------------------
    def CheckAll(self, argin=None):
        print "In ", self.get_name(), "::CheckAll()"
        #    Add your own code here
        
        confis,domreg,argfilters,argexclude = self.configs,self.domreg,self.argfilters,self.argexclude
        restart = self.Restart
        results = {}
        summary = {}
        failed = {}
        polizons = {}

        for schema in ('hdb','tdb'):
            print 'Checking %s configurations' % schema.upper()
        
            api = PyTangoArchiving.ArchivingAPI(schema,load=True)    
            active = [a for a in api if api[a].archiver]
            if not active: #No attributes being archived in the database
                continue
            dedicated = list(set([a for a in active if api[a].dedicated]))
            print 'There are %d dedicated attributes' % (len(dedicated))
            
            #Initializing variables
            results[schema] = {}
            summary[schema] = {'active':len(active),'dedicated':len(dedicated)}
            polizons[schema] = {}
            up,down,idle,archivers = [],[],[],api.check_archivers()
            for k,v in archivers.items():
                {True:up,False:down,None:idle}[v].append(k)
            summary[schema].update({'up':up,'down':down,'idle':idle,'archivers':archivers.keys()})
            
            ############################################################################
            #Checking Attribute Configuration CSV files
            ############################################################################
            if configs:
                polizons[schema] = active[:]
                for c in configs:
                    filters = dict(argfilters.items())
                    exclude = dict(argexclude.items())
                    try:
                        print '%s: Checking file %s' % (schema.upper(),c.split('/')[-1])
                        print 'filters: %s ; exclude: %s' % (filters,exclude)
                        
                        check = files.CheckArchivingConfiguration(
                            c,
                            api=api,schema=schema,
                            restart=bool(restart and fun.matchCl(restart,c)), #Restart has to be done here as it is where the modes configuration is available
                            filters=filters,exclude=exclude)
                            
                        if not any(check.values()): #No values returned?
                            continue    
                        
                        #Creating a summary of check results:
                        results[schema][c] = check
                        #check['rate'] = (float(len(check['ok']))/len(check['all'])) if (check['ok'] and check['all']) else 0.                    
                        print ('\n'.join('%s: %s'%(k.upper(),self.summarize(v)) for k,v in results[schema][c].items() if v))
                        [polizons[schema].remove(a.lower()) for a in check['all'] if a.lower() in polizons[schema]] #Checking how many attributes are 'alien' to specs
                        flie = open('/tmp/%s.%s.pck'%(c.split('/')[-1].rsplit('.',1)[0],schema),'w')
                        pickle.dump((c,check),flie)
                        flie.close()
                    except Exception,e:
                        if c in results[schema]: results[schema].pop(c)
                        failed['%s:%s'%(schema,c)] = traceback.format_exc()
                        print failed['%s:%s'%(schema,c)]
                                        
            ############################################################################
            #Doing a generic check of the archiving, ignoring configurations
            ############################################################################
            elif domreg:
                domains = defaultdict(list)
                [domains[a.split('/')[0].lower()].append(a) for a in api if fun.matchCl(domreg,a.split('/')[0]) and api[a].archiver]
                
                print ('Checking %s attributes by domain(%s): %s'%(schema,domreg,[(k,len(v)) for k,v in domains.items()]))
                for d,attributes in domains.items():
                    print '%d attributes in domain %s' % (len(attributes),d)
                    ok,lost,goods,bads,retried = [],[],[],[],[]
                    try:            
                        [(goods if utils.check_attribute(a,readable=True) else bads).append(a) for a in attributes]
                        if not goods:
                            continue
                        if goods: 
                            [(lost if v else ok).append(a) for k,v in api.check_attributes_errors(goods,hours=1,lazy=True).items()]
                        print '%d attributes on time'%len(ok)
                        if restart and lost:
                            for att in lost:
                                modes = api[att].modes
                                if not modes: continue
                                print 'Restarting archiving for %s' % att
                                if api.start_archiving([att],modes,load=False):
                                    retried.append(att)                  
                            
                        check = {'all':attributes,'ok':ok,'lost':lost,'retried':retried,'unavailable':bads} 
                        results[schema][d] = check
                        results[schema][d]['rate'] = (float(len(ok))/len(attributes)) if goods else 0
                        print ('\n'.join('%s: %s'%(k.upper(),summarize(v)) for k,v in results[schema][d].items() if v))
                    except Exception,e:
                        if d in results[schema]: results[schema].pop(d)
                        failed['%s:%s'%(schema,d)] = traceback.format_exc()
                        print failed['%s:%s'%(schema,d)]                
        
        return str(results) 

#------------------------------------------------------------------
#   GenerateHtml command:
#
#   Description: 
#   argin:  DevString   
#   argout: DevString   
#------------------------------------------------------------------
    def GenerateHtml(self, argin):
        print "In ", self.get_name(), "::GenerateHtml()"
        #   Add your own code here
        
        return argout

#==================================================================
#
#    PyArchivingWatcherClass class definition
#
#==================================================================
class PyArchivingWatcherClass(PyTango.PyDeviceClass):

    #    Class Properties
    class_property_list = {
        }


    #    Device Properties
    device_property_list = {
        'InputFiles':
            [PyTango.DevVarStringArray,
            "",
            [] ],
        'Filters':
            [PyTango.DevVarStringArray,
            "",
            [] ],
        'LogFile':
            [PyTango.DevString,
            "",
            [] ],
        'HtmlFile':
            [PyTango.DevString,
            "",
            [] ],
        'Crontab':
            [PyTango.DevString,
            "",
            [ "0 0 * * *" ] ],
        'ValidationMethod':
            [PyTango.DevString,
            "This will be a python callable string with the method to be used to change the state to ALARM",
            [] ],
        'Restart':
            [PyTango.DevBoolean,
            "",
            [ True ] ],
        }


    #    Command definitions
    cmd_list = {
        'CheckFile':
            [[PyTango.DevString, ""],
            [PyTango.DevString, ""]],
        #'CheckAll':
            #[[PyTango.DevVoid, ""],
            #[PyTango.DevString, ""]],
        'GenerateHtml':
            [[PyTango.DevString, ""],
            [PyTango.DevString, ""]],
        }


    #    Attribute definitions
    attr_list = {
        }


#------------------------------------------------------------------
#    PyArchivingWatcherClass Constructor
#------------------------------------------------------------------
    def __init__(self, name):
        PyTango.PyDeviceClass.__init__(self, name)
        self.set_type(name);
        print "In PyArchivingWatcherClass  constructor"

#==================================================================
#
#    PyArchivingWatcher class main method
#
#==================================================================
if __name__ == '__main__':
    try:
        py = PyTango.Util(sys.argv)
        py.add_TgClass(PyArchivingWatcherClass,PyArchivingWatcher,'PyArchivingWatcher')

        U = PyTango.Util.instance()
        U.server_init()
        U.server_run()

    except PyTango.DevFailed,e:
        print '-------> Received a DevFailed exception:',e
    except Exception,e:
        print '-------> An unforeseen exception occured....',e
